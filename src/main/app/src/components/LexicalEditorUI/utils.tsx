import { $generateHtmlFromNodes, $generateNodesFromDOM } from '@lexical/html';
import { AutoLinkNode, LinkNode } from '@lexical/link';
import { ListItemNode, ListNode } from '@lexical/list';
import { HeadingNode } from '@lexical/rich-text';
import {
  $getRoot,
  createEditor,
  CreateEditorArgs,
  ElementNode,
  LexicalEditor,
  TextNode,
  DOMExportOutput,
  $insertNodes,
  EditorState,
  $createParagraphNode,
  $isElementNode,
  $isDecoratorNode,
  $isTextNode,
  SerializedTextNode,
} from 'lexical';

function wrapElementWith(element: HTMLElement, tag: string): HTMLElement {
  const el = document.createElement(tag);
  el.appendChild(element);
  return el;
}

class CustomTextNode extends TextNode {
  static getType() {
    return 'CustomTextNode';
  }

  static clone(node: CustomTextNode): CustomTextNode {
    return new CustomTextNode(node.__text);
  }

  static importJSON(serializedNode: SerializedTextNode): CustomTextNode {
    const serialized = TextNode.importJSON(serializedNode);
    return new CustomTextNode(serialized.__text);
  }

  exportJSON(): SerializedTextNode {
    const node = super.exportJSON();
    node.type = 'CustomTextNode';
    return node;
  }

  exportDOM(_editor: LexicalEditor): DOMExportOutput {
    let element = document.createElement('span');
    element.textContent = this.getTextContent();

    // This is the only way to properly add support for most clients,
    // even if it's semantically incorrect to have to resort to using
    // <b>, <u>, <s>, <i> elements.
    if (this.hasFormat('bold')) {
      element = wrapElementWith(element, 'strong');
    }
    if (this.hasFormat('italic')) {
      element = wrapElementWith(element, 'em');
    }
    if (this.hasFormat('strikethrough')) {
      element = wrapElementWith(element, 's');
    }
    if (this.hasFormat('underline')) {
      element = wrapElementWith(element, 'u');
    }

    return {
      element,
    };
  }
}

export const LEXICAL_NODES = [
  HeadingNode,
  ListNode,
  ListItemNode,
  AutoLinkNode,
  LinkNode,
  CustomTextNode,
  {
    replace: TextNode,
    with: (node: TextNode) => {
      return new CustomTextNode(node.__text);
    },
  },
];

const editorConfig: CreateEditorArgs = {
  namespace: 'ImportExportEditor',
  onError: error => {
    console.error(error);
  },
  nodes: LEXICAL_NODES,
};

export const parseEditorState = (value: string): EditorState => {
  const parser = new DOMParser();
  const doc = parser.parseFromString(value, 'text/html');
  const editor = createEditor(editorConfig);
  editor.update(
    () => {
      const p = $createParagraphNode();
      $getRoot().append(p);
      p.select();
      const nodes = $generateNodesFromDOM(editor, doc);

      // insertNodes fails on empty nodes generated by whitespace in HTML, let's drop them out.
      const filteredNodes = nodes.filter(n => {
        return (
          n.getTextContent().trim() || $isElementNode(n) || $isDecoratorNode(n)
        );
      });
      $insertNodes(filteredNodes);
    },
    // Päivitetään synkronisesti!
    { discrete: true }
  );
  return editor.getEditorState();
};

const postprocessHtml = (html: string): string => {
  const parser = new DOMParser();
  const doc = parser.parseFromString(html, 'text/html');

  // unwrap unnecessary spans
  doc
    .querySelectorAll('span')
    .forEach(elem => elem.replaceWith(...elem.childNodes));

  // lexical produces extra line breaks inside empty paragraphs -
  // they can't be added purposefully so strip them off altogether
  for (const element of doc.querySelectorAll('p > br:only-child')) {
    if (element.parentNode?.textContent === '') {
      element.remove();
    }
  }

  // extra direction tags in paragraphs
  for (const element of doc.querySelectorAll('[dir]')) {
    element.removeAttribute('dir');
  }

  // to match old editor output
  for (const element of doc.querySelectorAll('a')) {
    element.setAttribute('rel', 'noopener noreferrer');
    element.setAttribute('target', '_blank');
  }

  return doc.body.innerHTML;
};

export const serializeEditorState = (value: EditorState): string => {
  const editor = createEditor(editorConfig);
  editor.setEditorState(value);

  let html = '';

  editor.update(
    () => {
      html = $generateHtmlFromNodes(editor, null);
    },
    // Päivitetään synkronisesti!
    { discrete: true }
  );

  return postprocessHtml(html);
};

export const createEmptyEditorState = () => {
  const editor = createEditor(editorConfig);
  return editor.getEditorState();
};

export const isEditorState = (value: unknown): value is EditorState => {
  const es = createEmptyEditorState();
  // Ei voida käyttää suoraan EditorState:a instanceof-tarkistuksessa, koska lexicalista exportataan vain tyyppi
  return value instanceof es.constructor;
};

export const isEmptyEditorState = (state: unknown) =>
  isEditorState(state) && state.isEmpty();

export function hasWhitespace(node: ElementNode): boolean {
  for (const child of node.getChildren()) {
    if (
      ($isElementNode(child) && !hasWhitespace(child)) ||
      ($isTextNode(child) && child.getTextContent().trim() !== '') ||
      $isDecoratorNode(child)
    ) {
      return false;
    }
  }
  return true;
}
export const isEditorEmpty = (value: EditorState) => {
  return value.read(() => {
    const root = $getRoot();
    const child = root.getFirstChild();

    if (
      child == null ||
      ($isElementNode(child) && child.isEmpty() && root.getChildrenSize() === 1)
    ) {
      return true;
    }

    return hasWhitespace(root);
  });
};
