import { $generateHtmlFromNodes, $generateNodesFromDOM } from '@lexical/html';
import { AutoLinkNode, LinkNode } from '@lexical/link';
import { ListItemNode, ListNode } from '@lexical/list';
import { HeadingNode } from '@lexical/rich-text';
import {
  $applyNodeReplacement,
  $createParagraphNode,
  $getRoot,
  $insertNodes,
  $isDecoratorNode,
  $isElementNode,
  createEditor,
  CreateEditorArgs,
  DOMConversionMap,
  DOMExportOutput,
  EditorConfig,
  EditorState,
  LexicalEditor,
  LineBreakNode,
  NodeKey,
  SerializedTextNode,
  TextNode,
} from 'lexical';

class CustomTextNode extends TextNode {
  constructor(text: string, key?: NodeKey) {
    super(text, key);
  }

  static getType() {
    return 'CustomTextNode';
  }

  static clone(node: CustomTextNode): CustomTextNode {
    return new CustomTextNode(node.__text, node.__key);
  }

  createDOM(config: EditorConfig, editor?: LexicalEditor): HTMLElement {
    return super.createDOM(config, editor);
  }

  static importJSON(serializedNode: SerializedTextNode): CustomTextNode {
    return $createCustomTextNode().updateFromJSON(serializedNode);
  }

  exportJSON(): SerializedTextNode {
    return {
      ...super.exportJSON(),
      type: 'CustomTextNode',
      version: 1,
    };
  }

  static importDOM(): DOMConversionMap | null {
    return super.importDOM();
  }

  exportDOM(editor: LexicalEditor): DOMExportOutput {
    return super.exportDOM(editor);
  }
}

export function $createCustomTextNode(text: string = ''): CustomTextNode {
  return $applyNodeReplacement(new CustomTextNode(text));
}

export const LEXICAL_NODES = [
  HeadingNode,
  ListNode,
  ListItemNode,
  AutoLinkNode,
  LinkNode,
  LineBreakNode,
  CustomTextNode,
  {
    replace: TextNode,
    withKlass: CustomTextNode,
    with: (node: TextNode) => {
      return $createCustomTextNode(node.__text);
    },
  },
];

const editorConfig: CreateEditorArgs = {
  namespace: 'ImportExportEditor',
  onError: error => {
    console.error(error);
  },
  nodes: LEXICAL_NODES,
};

export const parseEditorState = (value: string): EditorState => {
  const parser = new DOMParser();
  const doc = parser.parseFromString(value, 'text/html');
  const editor = createEditor(editorConfig);
  editor.update(
    () => {
      const p = $createParagraphNode();
      $getRoot().append(p);
      p.select();
      const nodes = $generateNodesFromDOM(editor, doc);

      // insertNodes fails on empty nodes generated by whitespace in HTML, let's drop them out.
      const filteredNodes = nodes.filter(n => {
        return (
          n.getTextContent().trim() || $isElementNode(n) || $isDecoratorNode(n)
        );
      });
      $insertNodes(filteredNodes);
    },
    // Päivitetään synkronisesti!
    { discrete: true }
  );
  return editor.getEditorState();
};

const postprocessHtml = (html: string): string => {
  const parser = new DOMParser();
  const doc = parser.parseFromString(html, 'text/html');

  // unwrap unnecessary spans
  doc
    .querySelectorAll('span')
    .forEach(elem => elem.replaceWith(...elem.childNodes));

  // unwrap unnecessary b-elements
  doc
    .querySelectorAll('b')
    .forEach(elem => elem.replaceWith(...elem.childNodes));

  // remove unnecessary style-attributes
  doc.querySelectorAll('strong').forEach(elem => elem.removeAttribute('style'));
  doc.querySelectorAll('em').forEach(elem => elem.removeAttribute('style'));

  // unwrap unnecessary i-elements
  doc
    .querySelectorAll('i')
    .forEach(elem => elem.replaceWith(...elem.childNodes));

  // lexical produces extra line breaks inside empty paragraphs -
  // they can't be added purposefully so strip them off altogether
  for (const element of doc.querySelectorAll('p > br:only-child')) {
    if (element.parentNode?.textContent === '') {
      element.remove();
    }
  }

  // extra direction tags in paragraphs
  for (const element of doc.querySelectorAll('[dir]')) {
    element.removeAttribute('dir');
  }

  // to match old editor output
  for (const element of doc.querySelectorAll('a')) {
    element.setAttribute('rel', 'noopener noreferrer');
    element.setAttribute('target', '_blank');
  }

  return doc.body.innerHTML;
};

export const serializeEditorState = (value: EditorState): string => {
  const editor = createEditor(editorConfig);
  editor.setEditorState(value);

  let html = '';

  editor.update(
    () => {
      html = $generateHtmlFromNodes(editor, null);
    },
    // Päivitetään synkronisesti!
    { discrete: true }
  );

  return postprocessHtml(html);
};

export const createEmptyEditorState = () => {
  const editor = createEditor(editorConfig);
  return editor.getEditorState();
};

export const isEditorState = (value: unknown): value is EditorState => {
  const es = createEmptyEditorState();
  // Ei voida käyttää suoraan EditorState:a instanceof-tarkistuksessa, koska lexicalista exportataan vain tyyppi
  return value instanceof es.constructor;
};

export const isEmptyEditorState = (state: unknown) =>
  isEditorState(state) && state.isEmpty();
